# -*- coding: utf-8 -*-
"""3A_CORONADO_MP2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PotkF68TvCWPm-TxJmlqtg9YJtgwnM-P

# **Machine Problem: Implementing a Logic-Based Model in Python**

# **1. Propositional Logic Operations**
"""

def and_operation(p, q):
    return p and q

def or_operation(p, q):
    return p or q

def not_operation(p):
    return not p

def implies_operation(p, q):
    return not p or q

p = True
q = False

print("AND Operation (p ∧ q):", and_operation(p, q))
print("OR Operation (p ∨ q):", or_operation(p, q))
print("NOT Operation (¬p):", not_operation(p))
print("IMPLIES Operation (p → q):", implies_operation(p, q))

"""# **2. Evaluate Logical Statements**"""

def evaluate(statement, values):
    if statement in values:
        return values[statement]
    elif statement.startswith("not "):
        return not evaluate(statement[4:], values)

    for op in ["and", "or", "implies"]:
        if op in statement:
            left, right = statement.split(" " + op + " ")
            if op == "and":
                return evaluate(left, values) and evaluate(right, values)
            elif op == "or":
                return evaluate(left, values) or evaluate(right, values)
            else:
                return not evaluate(left, values) or evaluate(right, values)

    raise ValueError("Invalid statement format.")

p = True
q = False
values = {"p": p, "q": q}

statement1 = "p and q"
statement2 = "p or q"
statement3 = "not p"
statement4 = "p implies q"

print(evaluate(statement1, values))
print(evaluate(statement2, values))
print(evaluate(statement3, values))
print(evaluate(statement4, values))

"""# **3. Extend to Predicate Logic**"""

def forall(predicate, domain):
    for element in domain:
        if not predicate(element):
            return False
    return True

def exists(predicate, domain):
    for element in domain:
        if predicate(element):
            return True
    return False

def is_even(x):
    return x % 2 == 0

def is_positive(x):
    return x > 0

numbers = [-2, -1, 0, 1, 2, 3, 4, 5]
positive_numbers = [1, 2, 3, 4, 5]

print(forall(is_even, numbers))
print(forall(is_positive, positive_numbers))

print(exists(is_even, numbers))
print(exists(is_positive, [-1, -2, -3]))

"""# **4. AI Agent Development**"""

class CookingAIAgent:
    def __init__(self):
        self.recipes = {
            "breakfast": {
                "Omelette": {"eggs", "cheese", "vegetables"},
                "Pancakes": {"flour", "eggs", "milk"}
            },
            "lunch": {
                "Salad": {"lettuce", "tomatoes", "dressing"},
                "Sandwich": {"bread", "cheese", "deli meat"}
            },
            "dinner": {
                "Pasta": {"pasta", "sauce", "cheese"},
                "Stir-fry": {"vegetables", "protein"}
            }
        }

    def suggest_recipe(self, available_ingredients, meal_type):
        """Suggests a recipe based on available ingredients and desired meal type."""
        available_ingredients_set = set(available_ingredients)

        if meal_type in self.recipes:
            for recipe, ingredients in self.recipes[meal_type].items():
                if ingredients.issubset(available_ingredients_set):
                    return f"You can make {recipe} for {meal_type}."

        return "Sorry, I don't have a recipe for that meal type with the given ingredients."

agent = CookingAIAgent()

available_ingredients = ["lettuce", "tomatoes", "dressing"]
meal_type = "lunch"

suggestion = agent.suggest_recipe(available_ingredients, meal_type)
print(suggestion)